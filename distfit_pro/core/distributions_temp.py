"""\nDistribution Classes with Self-Explanatory Behavior\n===================================================\n\nThis module contains statistical distribution classes where each:\n- Clearly explains parameters\n- Specifies appropriate data ranges\n- Demonstrates practical applications\n\n**30 Statistical Distributions:**\n- 25 Continuous Distributions\n- 5 Discrete Distributions\n"""\n\nfrom abc import ABC, abstractmethod\nfrom dataclasses import dataclass\nfrom typing import Dict, Any, Optional, Tuple, List\nimport numpy as np\nfrom scipy import stats\nfrom scipy.optimize import minimize, brentq\nfrom scipy.special import gamma as gamma_func\nfrom ..locales import t\n\n\n@dataclass\nclass DistributionInfo:\n    \"\"\"Information about a distribution\"\"\"\n    name: str\n    display_name: str\n    parameters: Dict[str, str]\n    support: str\n    use_cases: List[str]\n    characteristics: List[str]\n    warning: Optional[str] = None\n\n\nclass BaseDistribution(ABC):\n    \"\"\"\n    Base class for all distributions\n    \n    Each distribution must implement:\n    - pdf/pmf: probability density/mass function\n    - cdf: cumulative distribution function\n    - ppf: percent point function (inverse CDF)\n    - fit: parameter estimation from data\n    - explain: conceptual explanation\n    \n    Example:\n    --------\n    >>> from distfit_pro.core.distributions import get_distribution\n    >>> import numpy as np\n    >>> \n    >>> # Generate sample data\n    >>> data = np.random.normal(loc=10, scale=2, size=1000)\n    >>> \n    >>> # Fit distribution\n    >>> dist = get_distribution('normal')\n    >>> dist.fit(data, method='mle')\n    >>> \n    >>> # View summary\n    >>> print(dist.summary())\n    >>> \n    >>> # Get statistics\n    >>> print(f\"Mean: {dist.mean():.2f}\")\n    >>> print(f\"Std: {dist.std():.2f}\")\n    \"\"\"\n    \n    def __init__(self):\n        self.params: Optional[Dict[str, float]] = None\n        self.fitted: bool = False\n        self._scipy_dist = None\n        self._is_discrete = False\n        \n    @property\n    @abstractmethod\n    def info(self) -> DistributionInfo:\n        \"\"\"Distribution information\"\"\"\n        pass\n    \n    @abstractmethod\n    def pdf(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"Probability density/mass function\"\"\"\n        pass\n    \n    @abstractmethod\n    def cdf(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"Cumulative distribution function\"\"\"\n        pass\n    \n    @abstractmethod\n    def ppf(self, q: np.ndarray) -> np.ndarray:\n        \"\"\"Percent point function (inverse of CDF)\"\"\"\n        pass\n    \n    def logpdf(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"Log probability density\"\"\"\n        return np.log(self.pdf(x) + 1e-300)\n    \n    def logcdf(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"Log cumulative distribution\"\"\"\n        return np.log(self.cdf(x) + 1e-300)\n    \n    def sf(self, x: np.ndarray) -> np.ndarray:\n        \"\"\"Survival function (1 - CDF)\"\"\"\n        return 1.0 - self.cdf(x)\n    \n    def isf(self, q: np.ndarray) -> np.ndarray:\n        \"\"\"Inverse survival function\"\"\"\n        return self.ppf(1.0 - q)\n    \n    def rvs(self, size: int = 1, random_state: Optional[int] = None) -> np.ndarray:\n        \"\"\"\n        Generate random samples from the fitted distribution\n        \n        Parameters:\n        -----------\n        size : int\n            Number of random samples to generate\n        random_state : int, optional\n            Seed for reproducibility\n            \n        Returns:\n        --------\n        samples : np.ndarray\n            Random samples from the distribution\n            \n        Example:\n        --------\n        >>> dist = get_distribution('normal')\n        >>> dist.fit(data)\n        >>> samples = dist.rvs(size=100, random_state=42)\n        \"\"\"\n        if random_state is not None:\n            np.random.seed(random_state)\n        if self._scipy_dist and self.params:\n            return self._scipy_dist.rvs(**self.params, size=size, random_state=random_state)\n        u = np.random.uniform(0, 1, size)\n        return self.ppf(u)\n    \n    # ========== Distribution Statistics ==========\n    \n    def mean(self) -> float:\n        \"\"\"Distribution mean\"\"\"\n        if self._scipy_dist and self.params:\n            return self._scipy_dist.mean(**self.params)\n        raise NotImplementedError(f\"Mean not implemented for {self.info.name}\")\n    \n    def var(self) -> float:\n        \"\"\"Distribution variance\"\"\"\n        if self._scipy_dist and self.params:\n            return self._scipy_dist.var(**self.params)\n        raise NotImplementedError(f\"Variance not implemented for {self.info.name}\")\n    \n    def variance(self) -> float:\n        \"\"\"Alias for var()\"\"\"\n        return self.var()\n    \n    def std(self) -> float:\n        \"\"\"Distribution standard deviation\"\"\"\n        return np.sqrt(self.var())\n    \n    def median(self) -> float:\n        \"\"\"Distribution median (50th percentile)\"\"\"\n        return self.ppf(0.5)\n    \n    def mode(self) -> float:\n        \"\"\"\n        Distribution mode (value with highest density)\n        \n        Returns:\n        --------\n        mode : float\n            Value where PDF/PMF is maximum\n        \"\"\"\n        if hasattr(self, '_mode_at_zero') and self._mode_at_zero:\n            return 0.0\n        if hasattr(self, '_mode_value'):\n            return self._mode_value()\n        try:\n            x_min = self.ppf(0.01)\n            x_max = self.ppf(0.99)\n            from scipy.optimize import minimize_scalar\n            result = minimize_scalar(lambda x: -self.pdf(np.array([x]))[0], \n                                    bounds=(x_min, x_max), method='bounded')\n            return result.x\n        except:\n            return self.median()\n    \n    def skewness(self) -> float:\n        \"\"\"Distribution skewness (asymmetry)\"\"\"\n        if self._scipy_dist and self.params:\n            return self._scipy_dist.stats(**self.params, moments='s')\n        raise NotImplementedError(f\"Skewness not implemented for {self.info.name}\")\n    \n    def kurtosis(self) -> float:\n        \"\"\"Distribution kurtosis (tail heaviness)\"\"\"\n        if self._scipy_dist and self.params:\n            return self._scipy_dist.stats(**self.params, moments='k')\n        raise NotImplementedError(f\"Kurtosis not implemented for {self.info.name}\")\n    \n    def hazard_rate(self, t: float) -> float:\n        \"\"\"\n        Hazard rate (failure rate) at time t\n        \n        h(t) = f(t) / S(t) = pdf(t) / (1 - cdf(t))\n        \"\"\"\n        pdf_t = self.pdf(np.array([t]))[0]\n        sf_t = self.sf(np.array([t]))[0]\n        if sf_t < 1e-10:\n            return np.inf\n        return pdf_t / sf_t\n    \n    def reliability(self, t: float) -> float:\n        \"\"\"\n        Reliability function at time t\n        \n        R(t) = P(T > t) = 1 - F(t)\n        \"\"\"\n        return self.sf(np.array([t]))[0]\n    \n    def mean_time_to_failure(self) -> float:\n        \"\"\"Mean Time To Failure (MTTF) = E[T]\"\"\"\n        return self.mean()\n    \n    def conditional_var(self, alpha: float) -> float:\n        \"\"\"\n        Conditional Value at Risk (CVaR) / Expected Shortfall\n        \n        CVaR_Î± = E[X | X â‰¤ VaR_Î±]\n        \"\"\"\n        quantiles = np.linspace(0.0001, alpha, 100)\n        return np.mean(self.ppf(quantiles))\n    \n    # ========== Fitting Methods ==========\n    \n    @abstractmethod\n    def fit_mle(self, data: np.ndarray, **kwargs) -> Dict[str, float]:\n        \"\"\"Maximum Likelihood Estimation\"\"\"\n        pass\n    \n    @abstractmethod\n    def fit_moments(self, data: np.ndarray) -> Dict[str, float]:\n        \"\"\"Method of Moments\"\"\"\n        pass\n    \n    def fit(self, data: np.ndarray, method: str = 'mle', **kwargs) -> 'BaseDistribution':\n        \"\"\"\n        Fit distribution to data\n        \n        Parameters:\n        -----------\n        data : array-like\n            Observed data\n        method : str\n            Estimation method: 'mle', 'moments', 'quantile'\n            \n        Returns:\n        --------\n        self : BaseDistribution\n            Fitted distribution (for method chaining)\n            \n        Example:\n        --------\n        >>> dist = get_distribution('weibull')\n        >>> dist.fit(data, method='mle')\n        >>> print(dist.summary())\n        \"\"\"\n        data = np.asarray(data).flatten()\n        data = data[~np.isnan(data)]\n        \n        if method == 'mle':\n            self.params = self.fit_mle(data, **kwargs)\n        elif method == 'moments':\n            self.params = self.fit_moments(data)\n        elif method == 'quantile':\n            self.params = self.fit_quantile(data, **kwargs)\n        else:\n            raise ValueError(f\"Unknown method: {method}\")\n        \n        self.fitted = True\n        return self\n    \n    def fit_quantile(self, data: np.ndarray, quantiles: Optional[List[float]] = None) -> Dict[str, float]:\n        \"\"\"Quantile matching estimation\"\"\"\n        if quantiles is None:\n            quantiles = [0.25, 0.5, 0.75]\n        empirical_quantiles = np.quantile(data, quantiles)\n        \n        def objective(params_array):\n            self.params = self._array_to_params(params_array)\n            theoretical_quantiles = self.ppf(np.array(quantiles))\n            return np.sum((empirical_quantiles - theoretical_quantiles) ** 2)\n        \n        initial_params = self.fit_moments(data)\n        x0 = self._params_to_array(initial_params)\n        result = minimize(objective, x0, method='Nelder-Mead')\n        return self._array_to_params(result.x)\n    \n    def _params_to_array(self, params: Dict[str, float]) -> np.ndarray:\n        return np.array(list(params.values()))\n    \n    def _array_to_params(self, array: np.ndarray) -> Dict[str, float]:\n        keys = list(self.info.parameters.keys())\n        return dict(zip(keys, array))\n    \n    # ========== Summary & Explanation ==========\n    \n    def summary(self) -> str:\n        \"\"\"\n        Complete statistical summary of the fitted distribution\n        \n        Shows:\n        - Estimated parameters\n        - Location statistics (mean, median, mode)\n        - Spread statistics (variance, std)\n        - Shape statistics (skewness, kurtosis)\n        - Key quantiles\n        \n        Returns:\n        --------\n        summary : str\n            Formatted summary text\n            \n        Example:\n        --------\n        >>> dist = get_distribution('normal')\n        >>> dist.fit(data)\n        >>> print(dist.summary())\n        \"\"\"\n        if not self.fitted:\n            return f\"âš ï¸  {t('warning')}: {self.info.display_name} {t('not_fitted')}\"\n        \n        summary = f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  {self.info.display_name:^60}  â•‘\nâ• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\nâ•‘  ğŸ“Š {t('estimated_parameters'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        # Parameters\n        for param_name, param_value in self.params.items():\n            param_desc = self.info.parameters.get(param_name, param_name)\n            summary += f\"   {param_desc:<35} = {param_value:>15.6f}\\n\"\n        \n        # Location Statistics\n        summary += f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  ğŸ“ {t('location_statistics'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        try:\n            mean_val = self.mean()\n            if not np.isnan(mean_val):\n                summary += f\"   {t('mean'):<35} = {mean_val:>15.6f}\\n\"\n            else:\n                summary += f\"   {t('mean'):<35} = {t('undefined'):>15}\\n\"\n        except:\n            summary += f\"   {t('mean'):<35} = {t('na'):>15}\\n\"\n        \n        try:\n            summary += f\"   {t('median'):<35} = {self.median():>15.6f}\\n\"\n        except:\n            summary += f\"   {t('median'):<35} = {t('na'):>15}\\n\"\n        \n        try:\n            summary += f\"   {t('mode'):<35} = {self.mode():>15.6f}\\n\"\n        except:\n            summary += f\"   {t('mode'):<35} = {t('na'):>15}\\n\"\n        \n        # Spread Statistics\n        summary += f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  ğŸ“ {t('spread_statistics'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        try:\n            var_val = self.var()\n            if not np.isnan(var_val):\n                summary += f\"   {t('variance'):<35} = {var_val:>15.6f}\\n\"\n                summary += f\"   {t('std_deviation'):<35} = {np.sqrt(var_val):>15.6f}\\n\"\n            else:\n                summary += f\"   {t('variance'):<35} = {t('undefined'):>15}\\n\"\n                summary += f\"   {t('std_deviation'):<35} = {t('undefined'):>15}\\n\"\n        except:\n            summary += f\"   {t('variance'):<35} = {t('na'):>15}\\n\"\n            summary += f\"   {t('std_deviation'):<35} = {t('na'):>15}\\n\"\n        \n        # Shape Statistics\n        summary += f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  ğŸ“ {t('shape_statistics'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        try:\n            skew = self.skewness()\n            summary += f\"   {t('skewness'):<35} = {skew:>15.6f}\\n\"\n            if skew > 0.5:\n                summary += f\"      {t('right_skewed'):<35}\\n\"\n            elif skew < -0.5:\n                summary += f\"      {t('left_skewed'):<35}\\n\"\n            else:\n                summary += f\"      {t('symmetric'):<35}\\n\"\n        except:\n            summary += f\"   {t('skewness'):<35} = {t('na'):>15}\\n\"\n        \n        try:\n            kurt = self.kurtosis()\n            summary += f\"   {t('kurtosis'):<35} = {kurt:>15.6f}\\n\"\n            if kurt > 1:\n                summary += f\"      {t('heavy_tails'):<35}\\n\"\n            elif kurt < -1:\n                summary += f\"      {t('light_tails'):<35}\\n\"\n            else:\n                summary += f\"      {t('normal_tails'):<35}\\n\"\n        except:\n            summary += f\"   {t('kurtosis'):<35} = {t('na'):>15}\\n\"\n        \n        # Quantiles\n        summary += f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  ğŸ“Š {t('key_quantiles'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        quantiles = [0.01, 0.05, 0.25, 0.50, 0.75, 0.95, 0.99]\n        for q in quantiles:\n            try:\n                q_val = self.ppf(q)\n                p = int(q * 100)\n                summary += f\"   {t('percentile', p=p):<35} = {q_val:>15.6f}\\n\"\n            except:\n                pass\n        \n        summary += f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  â„¹ï¸  {t('for_explanation'):<58} â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\"\"\"\n        return summary\n    \n    def explain(self) -> str:\n        \"\"\"\n        Conceptual explanation of the distribution\n        \n        Focus on:\n        - Estimated parameters and their meaning\n        - Practical use cases\n        - Distribution characteristics\n        - Warnings and caveats\n        \n        For statistical summary, use .summary()\n        \n        Returns:\n        --------\n        explanation : str\n            Formatted explanation text\n        \"\"\"\n        if not self.fitted:\n            return f\"âš ï¸  {t('warning')}: {self.info.display_name} {t('not_fitted')}\"\n        \n        explanation = f\"\"\"\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\nâ•‘  {self.info.display_name:^60}  â•‘\nâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nğŸ“Š {t('estimated_parameters')}:\n\"\"\"\n        for param_name, param_value in self.params.items():\n            param_desc = self.info.parameters.get(param_name, param_name)\n            explanation += f\"   â€¢ {param_desc}: {param_value:.4f}\\n\"\n        \n        explanation += f\"\\nğŸ’¡ {t('practical_applications')}:\\n\"\n        for use_case in self.info.use_cases:\n            if use_case.startswith('use_'):\n                translated = t(use_case)\n            else:\n                translated = use_case\n            explanation += f\"   â€¢ {translated}\\n\"\n        \n        explanation += f\"\\nğŸ” {t('characteristics')}:\\n\"\n        for char in self.info.characteristics:\n            if char.startswith('char_'):\n                translated = t(char)\n            else:\n                translated = char\n            explanation += f\"   â€¢ {translated}\\n\"\n        \n        if self.info.warning:\n            if isinstance(self.info.warning, str) and self.info.warning.startswith('warn_'):\n                warning_text = t(self.info.warning)\n            else:\n                warning_text = self.info.warning\n            explanation += f\"\\nâš ï¸  {t('warning')}: {warning_text}\\n\"\n\n        explanation += f\"\\nğŸ“ˆ {t('for_statistics')}\\n\"\n        return explanation\n    \n    def __repr__(self) -> str:\n        if self.fitted:\n            params_str = \", \".join([f\"{k}={v:.3f}\" for k, v in self.params.items()])\n            return f\"{self.info.name}({params_str})\"\n        return f\"{self.info.name}(not fitted)\"\n\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# CONTINUOUS DISTRIBUTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nclass NormalDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.norm\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"normal\",\n            display_name=\"Normal (Gaussian) Distribution\",\n            parameters={\"loc\": \"Î¼ (mean)\", \"scale\": \"Ïƒ (std)\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_measurement_errors\", \"use_height_weight\", \"use_test_scores\", \"use_signal_noise\"],\n            characteristics=[\"char_symmetric\", \"char_68_in_1std\", \"char_95_in_2std\"],\n            warning=\"warn_not_for_skewed\"\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, **self.params)\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, **self.params)\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, **self.params)\n    def fit_mle(self, data, **kwargs):\n        return {\"loc\": np.mean(data), \"scale\": np.std(data, ddof=1)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass LognormalDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.lognorm\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"lognormal\",\n            display_name=\"Lognormal Distribution\",\n            parameters={\"s\": \"Ïƒ (log-scale)\", \"scale\": \"exp(Î¼)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_income\", \"use_stock_prices\", \"use_failure_time\"],\n            characteristics=[\"char_right_skewed\", \"char_positive_only\"],\n            warning=\"warn_positive_only\"\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['s'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['s'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['s'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        log_data = np.log(data)\n        return {\"s\": np.std(log_data, ddof=1), \"scale\": np.exp(np.mean(log_data))}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass WeibullDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.weibull_min\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"weibull\",\n            display_name=\"Weibull Distribution\",\n            parameters={\"c\": \"k (shape)\", \"scale\": \"Î» (scale)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_reliability\", \"use_failure_time\", \"use_wind_speed\"],\n            characteristics=[\"char_k_less_1_decreasing\", \"char_k_equals_1_exponential\", \"char_k_greater_1_aging\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['c'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['c'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['c'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        params = self._scipy_dist.fit(data, floc=0)\n        return {\"c\": params[0], \"scale\": params[2]}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass GammaDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.gamma\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"gamma\",\n            display_name=\"Gamma Distribution\",\n            parameters={\"a\": \"Î± (shape)\", \"scale\": \"Î¸ (scale)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_waiting_time\", \"use_rainfall\", \"use_bayesian_prior\"],\n            characteristics=[\"char_alpha_1_exponential\", \"char_alpha_large_normal\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['a'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['a'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['a'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        params = self._scipy_dist.fit(data, floc=0)\n        return {\"a\": params[0], \"scale\": params[2]}\n    def fit_moments(self, data):\n        m, v = np.mean(data), np.var(data, ddof=1)\n        return {\"a\": m*m/v, \"scale\": v/m}\n\n\nclass ExponentialDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.expon\n        self._mode_at_zero = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"exponential\",\n            display_name=\"Exponential Distribution\",\n            parameters={\"scale\": \"1/Î» (mean)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_time_between_events\", \"use_component_lifetime\"],\n            characteristics=[\"char_memoryless\", \"char_constant_hazard\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        return {\"scale\": np.mean(data[data > 0])}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass BetaDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.beta\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"beta\",\n            display_name=\"Beta Distribution\",\n            parameters={\"a\": \"Î± (shape 1)\", \"b\": \"Î² (shape 2)\"},\n            support=\"[0, 1]\",\n            use_cases=[\"use_probabilities\", \"use_success_rate\", \"use_bayesian_prior\"],\n            characteristics=[\"char_flexible\", \"char_bounded_0_1\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['a'], self.params['b'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['a'], self.params['b'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['a'], self.params['b'])\n    def fit_mle(self, data, **kwargs):\n        data = data[(data > 0) & (data < 1)]\n        params = self._scipy_dist.fit(data, floc=0, fscale=1)\n        return {\"a\": params[0], \"b\": params[1]}\n    def fit_moments(self, data):\n        m, v = np.mean(data), np.var(data, ddof=1)\n        common = m * (1 - m) / v - 1\n        return {\"a\": m * common, \"b\": (1 - m) * common}\n\n\nclass UniformDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.uniform\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"uniform\",\n            display_name=\"Uniform Distribution\",\n            parameters={\"loc\": \"a (min)\", \"scale\": \"b-a (width)\"},\n            support=\"[a, b]\",\n            use_cases=[\"use_random_number_gen\", \"use_uninformative_prior\"],\n            characteristics=[\"char_equal_probability\", \"char_maximum_entropy\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        return {\"loc\": np.min(data), \"scale\": np.max(data) - np.min(data)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass TriangularDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.triang\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"triangular\",\n            display_name=\"Triangular Distribution\",\n            parameters={\"c\": \"mode position\", \"loc\": \"min\", \"scale\": \"width\"},\n            support=\"[min, min+width]\",\n            use_cases=[\"use_pert\", \"use_expert_estimate\"],\n            characteristics=[\"char_simple\", \"char_intuitive\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['c'], self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['c'], self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['c'], self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        a, b = np.min(data), np.max(data)\n        c = (np.mean(data) - a) / (b - a) if b > a else 0.5\n        return {\"c\": c, \"loc\": a, \"scale\": b - a}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass LogisticDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.logistic\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"logistic\",\n            display_name=\"Logistic Distribution\",\n            parameters={\"loc\": \"Î¼ (location)\", \"scale\": \"s (scale)\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_logistic_regression\", \"use_growth_models\"],\n            characteristics=[\"char_heavier_tails_than_normal\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        return {\"loc\": np.mean(data), \"scale\": np.std(data) * np.sqrt(3) / np.pi}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass GumbelDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.gumbel_r\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"gumbel\",\n            display_name=\"Gumbel Distribution (Extreme Value Type I)\",\n            parameters={\"loc\": \"Î¼ (location)\", \"scale\": \"Î² (scale)\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_floods\", \"use_earthquakes\", \"use_extreme_max\"],\n            characteristics=[\"char_positive_skew\", \"char_extreme_values\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        params = self._scipy_dist.fit(data)\n        return {\"loc\": params[0], \"scale\": params[1]}\n    def fit_moments(self, data):\n        m, s = np.mean(data), np.std(data, ddof=1)\n        return {\"scale\": s * np.sqrt(6) / np.pi, \"loc\": m - 0.5772 * s * np.sqrt(6) / np.pi}\n\n\nclass FrechetDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.invweibull\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"frechet\",\n            display_name=\"Frechet Distribution (Extreme Value Type II)\",\n            parameters={\"c\": \"Î± (shape)\", \"scale\": \"s (scale)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_positive_extreme_max\", \"use_insurance\"],\n            characteristics=[\"char_very_heavy_tails\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['c'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['c'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['c'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        params = self._scipy_dist.fit(data, floc=0)\n        return {\"c\": params[0], \"scale\": params[2]}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass ParetoDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.pareto\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"pareto\",\n            display_name=\"Pareto Distribution\",\n            parameters={\"b\": \"Î± (shape)\", \"scale\": \"x_m (minimum)\"},\n            support=\"[x_m, +âˆ)\",\n            use_cases=[\"use_wealth\", \"use_income\", \"use_80_20_rule\"],\n            characteristics=[\"char_heavy_tails\", \"char_power_law\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['b'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['b'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['b'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        xm = np.min(data)\n        n = len(data)\n        alpha = n / np.sum(np.log(data / xm))\n        return {\"b\": alpha, \"scale\": xm}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass CauchyDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.cauchy\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"cauchy\",\n            display_name=\"Cauchy Distribution\",\n            parameters={\"loc\": \"x_0 (location)\", \"scale\": \"Î³ (scale)\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_physics\", \"use_resonance\"],\n            characteristics=[\"char_undefined_mean\", \"char_very_heavy_tails\"],\n            warning=\"warn_no_mean_variance\"\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        return {\"loc\": np.median(data), \"scale\": np.percentile(np.abs(data - np.median(data)), 50)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n    \n    def mean(self):\n        return np.nan\n    def var(self):\n        return np.nan\n\n\nclass StudentTDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.t\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"studentt\",\n            display_name=\"Student's t Distribution\",\n            parameters={\"df\": \"Î½ (degrees of freedom)\", \"loc\": \"Î¼\", \"scale\": \"Ïƒ\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_hypothesis_testing\", \"use_small_sample\"],\n            characteristics=[\"char_heavier_tails_than_normal\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['df'], self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['df'], self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['df'], self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        params = self._scipy_dist.fit(data)\n        return {\"df\": params[0], \"loc\": params[1], \"scale\": params[2]}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass ChiSquaredDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.chi2\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"chisquared\",\n            display_name=\"Chi-Squared Distribution\",\n            parameters={\"df\": \"k (degrees of freedom)\"},\n            support=\"[0, +âˆ)\",\n            use_cases=[\"use_gof_test\", \"use_variance\"],\n            characteristics=[\"char_special_case_gamma\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['df'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['df'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['df'])\n    def fit_mle(self, data, **kwargs):\n        return {\"df\": np.mean(data)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass FDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.f\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"f\",\n            display_name=\"F Distribution\",\n            parameters={\"dfn\": \"d1 (numerator df)\", \"dfd\": \"d2 (denominator df)\"},\n            support=\"[0, +âˆ)\",\n            use_cases=[\"use_anova\", \"use_variance_ratio\"],\n            characteristics=[\"char_skewed\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['dfn'], self.params['dfd'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['dfn'], self.params['dfd'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['dfn'], self.params['dfd'])\n    def fit_mle(self, data, **kwargs):\n        return {\"dfn\": 5, \"dfd\": 10}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass RayleighDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.rayleigh\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"rayleigh\",\n            display_name=\"Rayleigh Distribution\",\n            parameters={\"scale\": \"Ïƒ (scale)\"},\n            support=\"[0, +âˆ)\",\n            use_cases=[\"use_radar_signal\", \"use_wind_speed\"],\n            characteristics=[\"char_positive_skew\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data >= 0]\n        return {\"scale\": np.sqrt(np.mean(data**2) / 2)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass LaplaceDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.laplace\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"laplace\",\n            display_name=\"Laplace Distribution (Double Exponential)\",\n            parameters={\"loc\": \"Î¼ (location)\", \"scale\": \"b (scale)\"},\n            support=\"(-âˆ, +âˆ)\",\n            use_cases=[\"use_differences\", \"use_lasso\"],\n            characteristics=[\"char_heavier_tails_than_normal\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['loc'], self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['loc'], self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['loc'], self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        return {\"loc\": np.median(data), \"scale\": np.mean(np.abs(data - np.median(data)))}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass InverseGammaDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.invgamma\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"invgamma\",\n            display_name=\"Inverse Gamma Distribution\",\n            parameters={\"a\": \"Î± (shape)\", \"scale\": \"Î² (scale)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_variance_prior\"],\n            characteristics=[\"char_heavy_tails\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['a'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['a'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['a'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        params = self._scipy_dist.fit(data, floc=0)\n        return {\"a\": params[0], \"scale\": params[2]}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass LogLogisticDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.fisk\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"loglogistic\",\n            display_name=\"Log-Logistic Distribution\",\n            parameters={\"c\": \"Î± (shape)\", \"scale\": \"Î² (scale)\"},\n            support=\"(0, +âˆ)\",\n            use_cases=[\"use_survival_analysis\"],\n            characteristics=[\"char_heavy_tails\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pdf(x, self.params['c'], scale=self.params['scale'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['c'], scale=self.params['scale'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['c'], scale=self.params['scale'])\n    def fit_mle(self, data, **kwargs):\n        data = data[data > 0]\n        params = self._scipy_dist.fit(data, floc=0)\n        return {\"c\": params[0], \"scale\": params[2]}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# DISCRETE DISTRIBUTIONS\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nclass PoissonDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.poisson\n        self._is_discrete = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"poisson\",\n            display_name=\"Poisson Distribution\",\n            parameters={\"mu\": \"Î» (rate)\"},\n            support=\"{0, 1, 2, ...}\",\n            use_cases=[\"use_event_count\", \"use_call_count\"],\n            characteristics=[\"char_mean_eq_variance\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pmf(x, self.params['mu'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['mu'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['mu'])\n    def fit_mle(self, data, **kwargs):\n        return {\"mu\": np.mean(data)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass BinomialDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.binom\n        self._is_discrete = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"binomial\",\n            display_name=\"Binomial Distribution\",\n            parameters={\"n\": \"n (trials)\", \"p\": \"p (success prob)\"},\n            support=\"{0, 1, 2, ..., n}\",\n            use_cases=[\"use_success_failure_trials\"],\n            characteristics=[\"char_n_independent_trials\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pmf(x, self.params['n'], self.params['p'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['n'], self.params['p'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['n'], self.params['p'])\n    def fit_mle(self, data, **kwargs):\n        n = int(np.max(data))\n        p = np.mean(data) / n if n > 0 else 0.5\n        return {\"n\": n, \"p\": p}\n    def fit_moments(self, data):\n        m, v = np.mean(data), np.var(data, ddof=1)\n        p = 1 - v / m if m > 0 else 0.5\n        n = int(m / p) if p > 0 else 1\n        return {\"n\": max(n, 1), \"p\": np.clip(p, 0.01, 0.99)}\n\n\nclass NegativeBinomialDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.nbinom\n        self._is_discrete = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"nbinom\",\n            display_name=\"Negative Binomial Distribution\",\n            parameters={\"n\": \"r (successes)\", \"p\": \"p (success prob)\"},\n            support=\"{0, 1, 2, ...}\",\n            use_cases=[\"use_overdispersed_counts\"],\n            characteristics=[\"char_variance_gt_mean\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pmf(x, self.params['n'], self.params['p'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['n'], self.params['p'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['n'], self.params['p'])\n    def fit_mle(self, data, **kwargs):\n        m, v = np.mean(data), np.var(data, ddof=1)\n        p = m / v if v > m else 0.5\n        n = m * p / (1 - p) if p < 1 else 1\n        return {\"n\": max(n, 1), \"p\": np.clip(p, 0.01, 0.99)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass GeometricDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.geom\n        self._is_discrete = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"geometric\",\n            display_name=\"Geometric Distribution\",\n            parameters={\"p\": \"p (success prob)\"},\n            support=\"{1, 2, 3, ...}\",\n            use_cases=[\"use_time_to_first_success\"],\n            characteristics=[\"char_memoryless\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pmf(x, self.params['p'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['p'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['p'])\n    def fit_mle(self, data, **kwargs):\n        return {\"p\": 1.0 / np.mean(data)}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\nclass HypergeometricDistribution(BaseDistribution):\n    def __init__(self):\n        super().__init__()\n        self._scipy_dist = stats.hypergeom\n        self._is_discrete = True\n    \n    @property\n    def info(self) -> DistributionInfo:\n        return DistributionInfo(\n            name=\"hypergeometric\",\n            display_name=\"Hypergeometric Distribution\",\n            parameters={\"M\": \"population\", \"n\": \"successes in pop\", \"N\": \"draws\"},\n            support=\"{max(0, N+n-M), ..., min(n, N)}\",\n            use_cases=[\"use_sampling_without_replacement\"],\n            characteristics=[\"char_finite\"],\n        )\n    \n    def pdf(self, x):\n        return self._scipy_dist.pmf(x, self.params['M'], self.params['n'], self.params['N'])\n    def cdf(self, x):\n        return self._scipy_dist.cdf(x, self.params['M'], self.params['n'], self.params['N'])\n    def ppf(self, q):\n        return self._scipy_dist.ppf(q, self.params['M'], self.params['n'], self.params['N'])\n    def fit_mle(self, data, **kwargs):\n        N = int(np.max(data)) + 10\n        return {\"M\": N, \"n\": N // 2, \"N\": int(np.mean(data))}\n    def fit_moments(self, data):\n        return self.fit_mle(data)\n\n\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n# REGISTRY & FACTORY\n# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\nDISTRIBUTION_REGISTRY = {\n    'normal': NormalDistribution,\n    'lognormal': LognormalDistribution,\n    'weibull': WeibullDistribution,\n    'gamma': GammaDistribution,\n    'exponential': ExponentialDistribution,\n    'beta': BetaDistribution,\n    'uniform': UniformDistribution,\n    'triangular': TriangularDistribution,\n    'logistic': LogisticDistribution,\n    'gumbel': GumbelDistribution,\n    'frechet': FrechetDistribution,\n    'pareto': ParetoDistribution,\n    'cauchy': CauchyDistribution,\n    'studentt': StudentTDistribution,\n    'chisquared': ChiSquaredDistribution,\n    'f': FDistribution,\n    'rayleigh': RayleighDistribution,\n    'laplace': LaplaceDistribution,\n    'invgamma': InverseGammaDistribution,\n    'loglogistic': LogLogisticDistribution,\n    'poisson': PoissonDistribution,\n    'binomial': BinomialDistribution,\n    'nbinom': NegativeBinomialDistribution,\n    'geometric': GeometricDistribution,\n    'hypergeometric': HypergeometricDistribution,\n}\n\n\ndef get_distribution(name: str) -> BaseDistribution:\n    \"\"\"\n    Get distribution by name\n    \n    Parameters:\n    -----------\n    name : str\n        Distribution name (case-insensitive)\n        \n    Returns:\n    --------\n    dist : BaseDistribution\n        Distribution instance\n        \n    Example:\n    --------\n    >>> dist = get_distribution('normal')\n    >>> dist.fit(data)\n    >>> print(dist.summary())\n    \"\"\"\n    name = name.lower()\n    if name not in DISTRIBUTION_REGISTRY:\n        available = ', '.join(sorted(DISTRIBUTION_REGISTRY.keys()))\n        raise ValueError(f\"Unknown distribution '{name}'. Available: {available}\")\n    return DISTRIBUTION_REGISTRY[name]()\n\n\ndef list_distributions() -> List[str]:\n    \"\"\"List all available distributions (30 total)\"\"\"\n    return sorted(list(DISTRIBUTION_REGISTRY.keys()))\n\n\ndef list_continuous_distributions() -> List[str]:\n    \"\"\"List continuous distributions (20 total)\"\"\"\n    return [k for k, v in DISTRIBUTION_REGISTRY.items() if not get_distribution(k)._is_discrete]\n\n\ndef list_discrete_distributions() -> List[str]:\n    \"\"\"List discrete distributions (5 total)\"\"\"\n    return [k for k, v in DISTRIBUTION_REGISTRY.items() if get_distribution(k)._is_discrete]\n