"""\nComprehensive Test Suite for BaseDistribution\n==============================================\n\nTests all features of base.py to ensure correct implementation:\n- Fitting (MLE & MOM)\n- Probability functions (PDF, CDF, PPF, SF, ISF)\n- Statistics (mean, var, std, median, mode, skewness, kurtosis)\n- Model selection (AIC, BIC, log-likelihood)\n- Random sampling\n- Summary and explain\n- i18n support\n- Error handling\n- Data validation\n\nAuthor: Ali Sadeghi Aghili\n"""\n\nimport pytest\nimport numpy as np\nfrom numpy.testing import assert_array_almost_equal, assert_almost_equal\n\nfrom distfit_pro.core.distributions import get_distribution, list_distributions\nfrom distfit_pro.core.config import set_language, config\nfrom distfit_pro.locales import t\n\n\nclass TestFitting:\n    """Test distribution fitting methods"""\n    \n    def test_mle_fitting(self):\n        """Test Maximum Likelihood Estimation"""\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        \n        dist = get_distribution('normal')\n        dist.fit(data, method='mle')\n        \n        assert dist.fitted\n        assert 'loc' in dist.params\n        assert 'scale' in dist.params\n        assert_almost_equal(dist.params['loc'], 10, decimal=1)\n        assert_almost_equal(dist.params['scale'], 2, decimal=1)\n    \n    def test_mom_fitting(self):\n        """Test Method of Moments"""\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        \n        dist = get_distribution('normal')\n        dist.fit(data, method='mom')\n        \n        assert dist.fitted\n        assert_almost_equal(dist.params['loc'], np.mean(data), decimal=6)\n        assert_almost_equal(dist.params['scale'], np.std(data, ddof=1), decimal=6)\n    \n    def test_method_chaining(self):\n        """Test that fit() returns self for chaining"""\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        \n        dist = get_distribution('normal')\n        result = dist.fit(data)\n        \n        assert result is dist\n        assert dist.fitted\n    \n    def test_fitting_preserves_data(self):\n        """Test that original data is stored"""\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 100)\n        \n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        assert dist.data is not None\n        assert len(dist.data) == len(data)\n        assert_array_almost_equal(dist.data, data)\n\n\nclass TestDataValidation:\n    """Test data validation and error handling"""\n    \n    def test_empty_data_raises_error(self):\n        """Test that empty data raises ValueError"""\n        dist = get_distribution('normal')\n        \n        with pytest.raises(ValueError, match="empty"):\n            dist.fit([])\n    \n    def test_nan_data_raises_error(self):\n        """Test that NaN values raise ValueError"""\n        dist = get_distribution('normal')\n        data = np.array([1, 2, np.nan, 4, 5])\n        \n        with pytest.raises(ValueError, match="NaN"):\n            dist.fit(data)\n    \n    def test_inf_data_raises_error(self):\n        """Test that infinite values raise ValueError"""\n        dist = get_distribution('normal')\n        data = np.array([1, 2, np.inf, 4, 5])\n        \n        with pytest.raises(ValueError, match="infinite"):\n            dist.fit(data)\n    \n    def test_invalid_method_raises_error(self):\n        """Test that invalid fitting method raises ValueError"""\n        dist = get_distribution('normal')\n        data = np.random.normal(0, 1, 100)\n        \n        with pytest.raises(ValueError, match="Unknown method"):\n            dist.fit(data, method='invalid_method')\n\n\nclass TestProbabilityFunctions:\n    """Test probability density and distribution functions"""\n    \n    @pytest.fixture\n    def fitted_normal(self):\n        """Fixture providing a fitted normal distribution"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        return dist\n    \n    def test_pdf(self, fitted_normal):\n        """Test probability density function"""\n        x = np.array([0, 1, -1])\n        pdf_vals = fitted_normal.pdf(x)\n        \n        assert pdf_vals.shape == x.shape\n        assert np.all(pdf_vals > 0)\n        assert pdf_vals[0] > pdf_vals[1]  # PDF highest at mean\n    \n    def test_logpdf(self, fitted_normal):\n        """Test log probability density function"""\n        x = np.array([0, 1, -1])\n        logpdf_vals = fitted_normal.logpdf(x)\n        pdf_vals = fitted_normal.pdf(x)\n        \n        assert_array_almost_equal(logpdf_vals, np.log(pdf_vals))\n    \n    def test_cdf(self, fitted_normal):\n        """Test cumulative distribution function"""\n        x = np.array([-3, 0, 3])\n        cdf_vals = fitted_normal.cdf(x)\n        \n        assert cdf_vals.shape == x.shape\n        assert np.all((cdf_vals >= 0) & (cdf_vals <= 1))\n        assert cdf_vals[0] < cdf_vals[1] < cdf_vals[2]\n        assert_almost_equal(cdf_vals[1], 0.5, decimal=1)  # CDF(mean) ≈ 0.5\n    \n    def test_ppf(self, fitted_normal):\n        """Test percent point function (inverse CDF)"""\n        q = np.array([0.1, 0.5, 0.9])\n        ppf_vals = fitted_normal.ppf(q)\n        \n        assert ppf_vals.shape == q.shape\n        assert ppf_vals[0] < ppf_vals[1] < ppf_vals[2]\n        \n        # Test that PPF inverts CDF\n        cdf_vals = fitted_normal.cdf(ppf_vals)\n        assert_array_almost_equal(cdf_vals, q, decimal=4)\n    \n    def test_sf(self, fitted_normal):\n        """Test survival function"""\n        x = np.array([-3, 0, 3])\n        sf_vals = fitted_normal.sf(x)\n        cdf_vals = fitted_normal.cdf(x)\n        \n        assert_array_almost_equal(sf_vals, 1 - cdf_vals, decimal=10)\n    \n    def test_isf(self, fitted_normal):\n        """Test inverse survival function"""\n        q = np.array([0.1, 0.5, 0.9])\n        isf_vals = fitted_normal.isf(q)\n        ppf_vals = fitted_normal.ppf(1 - q)\n        \n        assert_array_almost_equal(isf_vals, ppf_vals, decimal=10)\n    \n    def test_unfitted_raises_error(self):\n        """Test that calling methods before fit() raises error"""\n        dist = get_distribution('normal')\n        \n        with pytest.raises(ValueError, match="Must call fit"):\n            dist.pdf(np.array([0]))\n        \n        with pytest.raises(ValueError, match="Must call fit"):\n            dist.cdf(np.array([0]))\n\n\nclass TestStatistics:\n    """Test statistical moments and properties"""\n    \n    @pytest.fixture\n    def fitted_normal(self):\n        """Fixture providing a fitted normal distribution"""\n        np.random.seed(42)\n        data = np.random.normal(5, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        return dist\n    \n    def test_mean(self, fitted_normal):\n        """Test mean calculation"""\n        mean_val = fitted_normal.mean()\n        assert_almost_equal(mean_val, 5, decimal=1)\n    \n    def test_variance(self, fitted_normal):\n        """Test variance calculation"""\n        var_val = fitted_normal.var()\n        assert_almost_equal(var_val, 4, decimal=0)  # 2^2 = 4\n    \n    def test_std(self, fitted_normal):\n        """Test standard deviation calculation"""\n        std_val = fitted_normal.std()\n        assert_almost_equal(std_val, 2, decimal=1)\n    \n    def test_median(self, fitted_normal):\n        """Test median calculation"""\n        median_val = fitted_normal.median()\n        mean_val = fitted_normal.mean()\n        # For normal distribution, median ≈ mean\n        assert_almost_equal(median_val, mean_val, decimal=2)\n    \n    def test_mode(self, fitted_normal):\n        """Test mode calculation"""\n        mode_val = fitted_normal.mode()\n        mean_val = fitted_normal.mean()\n        # For normal distribution, mode = mean\n        assert_almost_equal(mode_val, mean_val, decimal=6)\n    \n    def test_skewness(self, fitted_normal):\n        """Test skewness calculation"""\n        skew_val = fitted_normal.skewness()\n        # Normal distribution has zero skewness\n        assert_almost_equal(skew_val, 0, decimal=1)\n    \n    def test_kurtosis(self, fitted_normal):\n        """Test kurtosis calculation"""\n        kurt_val = fitted_normal.kurtosis()\n        # Normal distribution has zero excess kurtosis\n        assert_almost_equal(kurt_val, 0, decimal=1)\n    \n    def test_entropy(self, fitted_normal):\n        """Test differential entropy"""\n        entropy_val = fitted_normal.entropy()\n        assert entropy_val > 0\n\n\nclass TestModelSelection:\n    """Test model selection criteria"""\n    \n    @pytest.fixture\n    def fitted_dist_with_data(self):\n        """Fixture with fitted distribution and data"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 500)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        return dist, data\n    \n    def test_log_likelihood(self, fitted_dist_with_data):\n        """Test log-likelihood calculation"""\n        dist, data = fitted_dist_with_data\n        ll = dist.log_likelihood()\n        \n        assert isinstance(ll, (int, float))\n        assert ll < 0  # Log-likelihood is typically negative\n    \n    def test_log_likelihood_with_custom_data(self, fitted_dist_with_data):\n        """Test log-likelihood with custom data"""\n        dist, original_data = fitted_dist_with_data\n        new_data = np.random.normal(0, 1, 100)\n        \n        ll = dist.log_likelihood(new_data)\n        assert isinstance(ll, (int, float))\n    \n    def test_aic(self, fitted_dist_with_data):\n        """Test Akaike Information Criterion"""\n        dist, data = fitted_dist_with_data\n        aic_val = dist.aic()\n        \n        assert isinstance(aic_val, (int, float))\n        # AIC = 2k - 2*log(L), should be positive for most cases\n        assert aic_val > 0\n    \n    def test_bic(self, fitted_dist_with_data):\n        """Test Bayesian Information Criterion"""\n        dist, data = fitted_dist_with_data\n        bic_val = dist.bic()\n        \n        assert isinstance(bic_val, (int, float))\n        assert bic_val > 0\n    \n    def test_bic_penalizes_more_than_aic(self, fitted_dist_with_data):\n        """Test that BIC penalizes complexity more than AIC"""\n        dist, data = fitted_dist_with_data\n        aic_val = dist.aic()\n        bic_val = dist.bic()\n        \n        # For large samples, BIC > AIC\n        if len(data) > 10:\n            assert bic_val > aic_val\n\n\nclass TestRandomSampling:\n    """Test random sample generation"""\n    \n    def test_rvs_basic(self):\n        """Test basic random variate generation"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        samples = dist.rvs(size=100, random_state=42)\n        \n        assert len(samples) == 100\n        assert isinstance(samples, np.ndarray)\n    \n    def test_rvs_reproducibility(self):\n        """Test that random_state ensures reproducibility"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        samples1 = dist.rvs(size=100, random_state=42)\n        samples2 = dist.rvs(size=100, random_state=42)\n        \n        assert_array_almost_equal(samples1, samples2)\n    \n    def test_rvs_matches_distribution(self):\n        """Test that generated samples match fitted distribution"""\n        np.random.seed(42)\n        data = np.random.normal(5, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        samples = dist.rvs(size=10000, random_state=42)\n        \n        # Check that sample statistics are close to fitted parameters\n        assert_almost_equal(np.mean(samples), 5, decimal=1)\n        assert_almost_equal(np.std(samples), 2, decimal=1)\n\n\nclass TestSummaryAndExplain:\n    """Test output formatting methods"""\n    \n    def test_summary_unfitted(self):\n        """Test summary for unfitted distribution"""\n        dist = get_distribution('normal')\n        summary = dist.summary()\n        \n        assert 'not fitted' in summary.lower()\n        assert 'Normal' in summary\n    \n    def test_summary_fitted(self):\n        """Test summary for fitted distribution"""\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        summary = dist.summary()\n        \n        assert '╔' in summary and '╗' in summary  # Box characters\n        assert 'Normal' in summary\n        assert 'μ' in summary or 'loc' in summary\n        assert 'σ' in summary or 'scale' in summary\n        assert len(summary.split('\\n')) > 10  # Multiple lines\n    \n    def test_explain(self):\n        """Test explain method"""\n        dist = get_distribution('normal')\n        explanation = dist.explain()\n        \n        assert isinstance(explanation, str)\n        assert len(explanation) > 0\n        assert 'normal' in explanation.lower() or 'gaussian' in explanation.lower()\n    \n    def test_str_representation(self):\n        """Test __str__ returns summary"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 100)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        str_repr = str(dist)\n        summary = dist.summary()\n        \n        assert str_repr == summary\n    \n    def test_repr(self):\n        """Test __repr__ representation"""\n        dist = get_distribution('normal')\n        repr_str = repr(dist)\n        \n        assert 'Normal' in repr_str\n        assert 'not fitted' in repr_str\n        \n        dist.fit(np.random.normal(0, 1, 100))\n        repr_str = repr(dist)\n        \n        assert 'fitted' in repr_str\n\n\nclass TestInternationalization:\n    """Test i18n support"""\n    \n    def test_summary_english(self):\n        """Test summary in English"""\n        set_language('en')\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        summary = dist.summary()\n        \n        assert 'Mean' in summary or 'LOCATION' in summary\n        assert 'Std' in summary or 'SPREAD' in summary\n    \n    def test_summary_persian(self):\n        """Test summary in Persian"""\n        set_language('fa')\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        summary = dist.summary()\n        \n        # Check for Persian text (RTL characters)\n        assert any(ord(c) > 1536 for c in summary)  # Persian Unicode range\n    \n    def test_summary_german(self):\n        """Test summary in German"""\n        set_language('de')\n        np.random.seed(42)\n        data = np.random.normal(10, 2, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        summary = dist.summary()\n        \n        # Reset to English\n        set_language('en')\n        \n        assert 'Mittelwert' in summary or 'LAGE' in summary\n\n\nclass TestParameterManagement:\n    """Test parameter access and manipulation"""\n    \n    def test_params_before_fit_raises_error(self):\n        """Test that accessing params before fit raises error"""\n        dist = get_distribution('normal')\n        \n        with pytest.raises(ValueError, match="not fitted"):\n            _ = dist.params\n    \n    def test_params_after_fit(self):\n        """Test params property after fitting"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        params = dist.params\n        \n        assert isinstance(params, dict)\n        assert 'loc' in params\n        assert 'scale' in params\n    \n    def test_params_returns_copy(self):\n        """Test that params returns a copy, not reference"""\n        np.random.seed(42)\n        data = np.random.normal(0, 1, 1000)\n        dist = get_distribution('normal')\n        dist.fit(data)\n        \n        params1 = dist.params\n        params2 = dist.params\n        \n        assert params1 is not params2\n        assert params1 == params2\n    \n    def test_manual_parameter_setting(self):\n        """Test setting parameters manually"""\n        dist = get_distribution('normal')\n        dist.params = {'loc': 5.0, 'scale': 2.0}\n        \n        assert dist.fitted\n        assert dist.params['loc'] == 5.0\n        assert dist.params['scale'] == 2.0\n    \n    def test_fitted_property(self):\n        """Test fitted property"""\n        dist = get_distribution('normal')\n        \n        assert not dist.fitted\n        \n        dist.fit(np.random.normal(0, 1, 100))\n        \n        assert dist.fitted\n\n\nclass TestDistributionRegistry:\n    """Test distribution registry and factory"""\n    \n    def test_list_distributions(self):\n        """Test listing all available distributions"""\n        dists = list_distributions()\n        \n        assert isinstance(dists, list)\n        assert len(dists) > 0\n        assert 'normal' in dists\n        assert 'exponential' in dists\n    \n    def test_get_distribution_valid(self):\n        """Test getting a valid distribution"""\n        dist = get_distribution('normal')\n        \n        assert dist is not None\n        assert dist.info.name == 'normal'\n    \n    def test_get_distribution_invalid(self):\n        """Test getting invalid distribution raises error"""\n        with pytest.raises((ValueError, KeyError)):\n            get_distribution('nonexistent_distribution')\n\n\nif __name__ == '__main__':\n    pytest.main([__file__, '-v', '--tb=short'])\n