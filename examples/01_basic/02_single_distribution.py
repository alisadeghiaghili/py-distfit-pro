"""\nSingle Distribution Fitting\n============================\n\nDetailed guide to fitting a single distribution when you already\nknow which family to use (Normal, Gamma, Weibull, etc.).\n\nUse Case:\n---------\nYou have domain knowledge that your data follows a specific\ndistribution (e.g., Normal for measurements, Exponential for\nwaiting times) and want to estimate its parameters.\n\nAuthor: Ali Sadeghi Aghili\n\"\"\"\n\nimport numpy as np\nfrom distfit_pro import get_distribution\nfrom distfit_pro.core.config import config\n\nprint(\"‚ïê" * 70)\nprint(\"üìä SINGLE DISTRIBUTION FITTING\")\nprint(\"‚ïê" * 70)\n\n\n# ============================================================================\n# EXAMPLE 1: Normal Distribution (Measurements)\n# ============================================================================\n\nprint(\"\\n" + \"‚îÄ" * 70)\nprint(\"Example 1: Normal Distribution - Product Weights\\n\")\n\n# Manufacturing: widget weights (grams)\nnp.random.seed(42)\ntrue_mean = 500.0\ntrue_std = 5.0\nweights = np.random.normal(true_mean, true_std, 200)\n\nprint(f\"Sample: {len(weights)} widgets\")\nprint(f\"Measured mean: {weights.mean():.2f}g\")\nprint(f\"Measured std:  {weights.std():.2f}g\\n\")\n\n# Fit Normal distribution\ndist = get_distribution('normal')\ndist.fit(weights)\n\nprint(\"Fitted Distribution:\")\nprint(dist.summary())\n\n# Practical questions\nprint(\"\\nüîç Quality Control Analysis:\")\nspec_lower = 490\nspec_upper = 510\n\n# Probability within spec\np_in_spec = dist.cdf(spec_upper) - dist.cdf(spec_lower)\nprint(f\"‚Ä¢ {p_in_spec*100:.2f}% of products within spec ({spec_lower}-{spec_upper}g)\")\n\n# Defect rate\np_underweight = dist.cdf(spec_lower)\np_overweight = 1 - dist.cdf(spec_upper)\nprint(f\"‚Ä¢ {p_underweight*100:.3f}% underweight (< {spec_lower}g)\")\nprint(f\"‚Ä¢ {p_overweight*100:.3f}% overweight (> {spec_upper}g)\")\n\n\n# ============================================================================\n# EXAMPLE 2: Exponential Distribution (Waiting Times)\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"Example 2: Exponential Distribution - Customer Arrivals\\n\")\n\n# Call center: time between calls (minutes)\ntrue_rate = 1/5  # Average 5 minutes between calls\ninter_arrival_times = np.random.exponential(1/true_rate, 500)\n\nprint(f\"Sample: {len(inter_arrival_times)} inter-arrival times\")\nprint(f\"Mean time between calls: {inter_arrival_times.mean():.2f} min\\n\")\n\n# Fit Exponential\ndist = get_distribution('exponential')\ndist.fit(inter_arrival_times)\n\nprint(\"Fitted Distribution:\")\nprint(dist.summary())\n\n# Staffing questions\nprint(\"\\nüîç Staffing Analysis:\")\n\n# P(next call within 2 minutes)\np_within_2min = dist.cdf(2)\nprint(f\"‚Ä¢ {p_within_2min*100:.1f}% chance next call within 2 min\")\n\n# P(wait more than 10 minutes)\np_wait_10min = 1 - dist.cdf(10)\nprint(f\"‚Ä¢ {p_wait_10min*100:.1f}% chance of 10+ min quiet period\")\n\n# Expected calls per hour\nexpected_per_hour = 60 / dist.mean()\nprint(f\"‚Ä¢ Expected calls per hour: {expected_per_hour:.1f}\")\n\n\n# ============================================================================\n# EXAMPLE 3: Gamma Distribution (Project Durations)\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"Example 3: Gamma Distribution - Task Completion Times\\n\")\n\n# Software: task completion times (hours)\n# Gamma is good for durations with a minimum (can't be instant)\ntask_times = np.random.gamma(shape=3, scale=2, size=300)\n\nprint(f\"Sample: {len(task_times)} completed tasks\")\nprint(f\"Mean duration: {task_times.mean():.1f} hours\")\nprint(f\"Median duration: {np.median(task_times):.1f} hours\\n\")\n\n# Fit Gamma\ndist = get_distribution('gamma')\ndist.fit(task_times)\n\nprint(\"Fitted Distribution:\")\nprint(dist.summary())\n\n# Planning questions\nprint(\"\\nüîç Sprint Planning:\")\n\n# P(task done in 4 hours)\np_done_4h = dist.cdf(4)\nprint(f\"‚Ä¢ {p_done_4h*100:.1f}% of tasks done within 4 hours\")\n\n# 90th percentile (for pessimistic estimates)\np90 = dist.ppf(0.90)\nprint(f\"‚Ä¢ 90th percentile duration: {p90:.1f} hours\")\nprint(f\"  (Use this for sprint planning buffer)\")\n\n# Expected duration for 10 tasks\nexpected_10_tasks = dist.mean() * 10\nprint(f\"‚Ä¢ Expected total for 10 tasks: {expected_10_tasks:.1f} hours\")\n\n\n# ============================================================================\n# EXAMPLE 4: Weibull Distribution (Reliability)\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"Example 4: Weibull Distribution - Component Lifetimes\\n\")\n\n# Engineering: LED bulb lifetimes (hours)\n# Weibull models wear-out failures\nlifetimes = np.random.weibull(a=2.5, size=150) * 10000\n\nprint(f\"Sample: {len(lifetimes)} bulbs tested\")\nprint(f\"Mean lifetime: {lifetimes.mean():.0f} hours\")\nprint(f\"Median lifetime: {np.median(lifetimes):.0f} hours\\n\")\n\n# Fit Weibull\ndist = get_distribution('weibull')\ndist.fit(lifetimes)\n\nprint(\"Fitted Distribution:\")\nprint(dist.summary())\n\n# Warranty analysis\nprint(\"\\nüîç Warranty Analysis:\")\n\n# P(failure before 5000 hours)\nwarranty_period = 5000\np_fail_warranty = dist.cdf(warranty_period)\nprint(f\"‚Ä¢ {p_fail_warranty*100:.2f}% fail before {warranty_period}h warranty\")\n\n# Median lifetime (50% survival)\nmedian_life = dist.median()\nprint(f\"‚Ä¢ Median lifetime: {median_life:.0f} hours\")\n\n# MTTF (Mean Time To Failure)\nmttf = dist.mean()\nprint(f\"‚Ä¢ MTTF: {mttf:.0f} hours\")\n\n\n# ============================================================================\n# EXAMPLE 5: Method Comparison (MLE vs Method of Moments)\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"Example 5: Comparing Estimation Methods\\n\")\n\n# Generate data\ndata = np.random.normal(100, 15, 500)\n\nprint(\"Fitting Normal distribution with two methods:\\n\")\n\n# Method 1: MLE (default)\ndist_mle = get_distribution('normal')\ndist_mle.fit(data, method='mle')\nprint(\"MLE (Maximum Likelihood):\")\nprint(f\"  Œº = {dist_mle.params['loc']:.3f}\")\nprint(f\"  œÉ = {dist_mle.params['scale']:.3f}\")\nprint(f\"  Log-Likelihood = {dist_mle.log_likelihood():.2f}\")\nprint(f\"  AIC = {dist_mle.aic():.2f}\\n\")\n\n# Method 2: Method of Moments (faster)\ndist_mom = get_distribution('normal')\ndist_mom.fit(data, method='mom')\nprint(\"Method of Moments:\")\nprint(f\"  Œº = {dist_mom.params['loc']:.3f}\")\nprint(f\"  œÉ = {dist_mom.params['scale']:.3f}\")\nprint(f\"  Log-Likelihood = {dist_mom.log_likelihood():.2f}\")\nprint(f\"  AIC = {dist_mom.aic():.2f}\\n\")\n\nprint(\"üìù Note: MLE usually more accurate, MOM faster.\")\nprint(\"   For Normal distribution, they're almost identical!\")\n\n\n# ============================================================================\n# EXAMPLE 6: Using Verbose Mode for Learning\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"Example 6: Verbose Mode (Educational)\\n\")\n\n# Turn on verbose mode\nconfig.set_verbosity('verbose')\n\nprint(\"Fitting with VERBOSE mode (explains each step):\\n\")\n\ndata = np.random.lognormal(2, 0.5, 200)\ndist = get_distribution('lognormal')\ndist.fit(data)  # Will show detailed explanations\n\n# Turn off verbose\nconfig.set_verbosity('normal')\n\n\n# ============================================================================\n# KEY TAKEAWAYS\n# ============================================================================\n\nprint(\"\\n" + \"‚ïê" * 70)\nprint(\"üéì KEY TAKEAWAYS\")\nprint(\"‚ïê" * 70)\nprint(\"\"\"\n1. CHOOSE RIGHT DISTRIBUTION:\n   - Normal: Symmetric measurements (heights, weights, errors)\n   - Exponential: Memoryless waiting times (calls, failures)\n   - Gamma: Task durations (has minimum time)\n   - Weibull: Reliability (wear-out failures)\n   - Lognormal: Right-skewed positive data (incomes, file sizes)\n\n2. ACCESS METHODS:\n   - dist.params: Get fitted parameters\n   - dist.cdf(x): Cumulative probability\n   - dist.ppf(q): Quantile function (inverse CDF)\n   - dist.mean(), dist.median(), dist.std(): Moments\n   - dist.summary(): Full statistical summary\n\n3. ESTIMATION METHODS:\n   - MLE (default): Most accurate, slower\n   - Method of Moments: Faster, less accurate\n   - Use MLE unless you have huge datasets\n\n4. NEXT STEPS:\n   - See 03_compare_distributions.py to test multiple families\n   - See 05_goodness_of_fit.py for validation tests\n   - See examples/02_advanced/ for advanced techniques\n\"\"\")\